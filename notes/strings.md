<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. String Algoritms</a>
<ul>
<li><a href="#sec-1-1">1.1. Burrows Wheeler Transform</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. Burrows Wheeler Transform (block sorting compression)</a></li>
<li><a href="#sec-1-1-2">1.1.2. Inverting the Burrows Wheeler Transform</a></li>
<li><a href="#sec-1-1-3">1.1.3. Pattern Matching Using the Burrows Wheeler Transform</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. Suffix Arrays</a>
<ul>
<li><a href="#sec-1-2-1">1.2.1. Suffix Arrays</a></li>
<li><a href="#sec-1-2-2">1.2.2. Pattern Matching Using Suffix Arrays</a></li>
</ul>
</li>
<li><a href="#sec-1-3">1.3. Approximate Pattern Matching , and Mutations and the Genome</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Knuth Morris Pratt Algorithm</a>
<ul>
<li><a href="#sec-2-1">2.1. Exact Pattern Matching</a></li>
<li><a href="#sec-2-2">2.2. Safe Shift</a></li>
<li><a href="#sec-2-3">2.3. Prefix Function</a></li>
<li><a href="#sec-2-4">2.4. Computing the Prefix Fucntion</a></li>
<li><a href="#sec-2-5">2.5. Knuth-Morris-Pratt Algorithm</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Constructing Suffix Array and Suffix Tree</a>
<ul>
<li><a href="#sec-3-1">3.1. Suffix Array Construction</a>
<ul>
<li><a href="#sec-3-1-1">3.1.1. Suffix Array</a></li>
<li><a href="#sec-3-1-2">3.1.2. General Stratergy</a></li>
<li><a href="#sec-3-1-3">3.1.3. Initialization</a></li>
<li><a href="#sec-3-1-4">3.1.4. Counting sort</a></li>
<li><a href="#sec-3-1-5">3.1.5. Sort Doubled Cyclic Shifts</a></li>
<li><a href="#sec-3-1-6">3.1.6. SortDouble Implementation</a></li>
<li><a href="#sec-3-1-7">3.1.7. Updating Classes</a></li>
<li><a href="#sec-3-1-8">3.1.8. Full Algorithm</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

# String Algoritms<a id="sec-1" name="sec-1"></a>

## Burrows Wheeler Transform<a id="sec-1-1" name="sec-1-1"></a>

### Burrows Wheeler Transform (block sorting compression)<a id="sec-1-1-1" name="sec-1-1-1"></a>

A **reversible** transformation of a string allows for more efficient
run length encoding of strings by increasing probability of frequenty
appearing characters end up in the long rungs allowing for better rung
compression.

For Exampe:

<!-- This HTML table template is generated by emacs 26.0.50 -->
<table border="1">
  <tr>
    <td align="left" valign="top">
      &nbsp;Input&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;Output&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
    </td>
  </tr>
  <tr>
    <td align="left" valign="top">
      &nbsp;SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES$&nbsp;
    </td>
    <td align="left" valign="top">
      &nbsp;TEXYDST.E.IXIXIXXSSMPPS.B..E.S.EUSFXDIIOIIIT&nbsp;
    </td>
  </tr>
</table>

### Inverting the Burrows Wheeler Transform<a id="sec-1-1-2" name="sec-1-1-2"></a>

### Pattern Matching Using the Burrows Wheeler Transform<a id="sec-1-1-3" name="sec-1-1-3"></a>

## Suffix Arrays<a id="sec-1-2" name="sec-1-2"></a>

### Suffix Arrays<a id="sec-1-2-1" name="sec-1-2-1"></a>

### Pattern Matching Using Suffix Arrays<a id="sec-1-2-2" name="sec-1-2-2"></a>

## Approximate Pattern Matching , and Mutations and the Genome<a id="sec-1-3" name="sec-1-3"></a>

**\***

# Knuth Morris Pratt Algorithm<a id="sec-2" name="sec-2"></a>

## Exact Pattern Matching<a id="sec-2-1" name="sec-2-1"></a>

## Safe Shift<a id="sec-2-2" name="sec-2-2"></a>

## Prefix Function<a id="sec-2-3" name="sec-2-3"></a>

## Computing the Prefix Fucntion<a id="sec-2-4" name="sec-2-4"></a>

## Knuth-Morris-Pratt Algorithm<a id="sec-2-5" name="sec-2-5"></a>

# Constructing Suffix Array and Suffix Tree<a id="sec-3" name="sec-3"></a>

## Suffix Array Construction<a id="sec-3-1" name="sec-3-1"></a>

### Suffix Array<a id="sec-3-1-1" name="sec-3-1-1"></a>

Given an ordered alphabet set. string S is lexicographicaly
smaller than T. there is an i in [0..|S|] such that
1.  S[0..i-1] == T[0..i-1]
2.  S[i]<T[i]
    or.
3.  S[i] is a prefix of T[i] (using '$' at the end of suffixes will avoid this)

S = ababaa

Suffixes(anchored the end or string) in lexicographic order:

a
aa
abaa
ababaa
baa
babaa

adding '$' will prevent cases where S[i] is a prefix of T[i]

1.  Storing suffix arrays.

    Number al suffixes ababaa$ is suffix 0 , abaa$ is suffix 2
    Suffix ordering can be stored as an array.
    [0,2,&#x2026;]

2.  Creating suffix array

    start with string ababaa$ and consider all lexicographic sorted
    cyclic shifts :
    
    <table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
    
    
    <colgroup>
    <col  class="left" />
    
    <col  class="left" />
    </colgroup>
    <tbody>
    <tr>
    <td class="left">Sorted Cyclic Shift</td>
    <td class="left">Chopped Prefix</td>
    </tr>
    
    
    <tr>
    <td class="left">$ababaa</td>
    <td class="left">$</td>
    </tr>
    
    
    <tr>
    <td class="left">a$ababa</td>
    <td class="left">a$</td>
    </tr>
    
    
    <tr>
    <td class="left">aa$abab</td>
    <td class="left">aa$</td>
    </tr>
    
    
    <tr>
    <td class="left">abaa$ab</td>
    <td class="left">abaa$</td>
    </tr>
    
    
    <tr>
    <td class="left">ababaa$</td>
    <td class="left">ababaa$</td>
    </tr>
    
    
    <tr>
    <td class="left">babaa$a</td>
    <td class="left">babaa$</td>
    </tr>
    </tbody>
    </table>
    
    Sorting cyclic shifts and sorting suffixes is equivalent.
    
    1.  Start with sorting partial cyclic of length L.
    2.  Construct partial cyclic shift of lenght 2|L| using
        partial cyclic shift of |L|.

3.  Start with Counting Sort

    \#+BEGIN<sub>SRC</sub> python
    
    order  = [] */ array size of |S|
    count  = [] /* counts size of |L| of alpbabet
    
    for i in range(0, len(S) -1):
        count[S[i]] = count[S[i]]+1;
    
    // Count now has the frequencies of each alphabet letter in |S|
    
    for j in range(1,len(L)-1):
       cout[j] = count[j] + count[j-1]
    
    // Count contains the partial sums/starting positions for each alphabet
    
    for i in range(len(S)-1 , 0):
      c = S[i] */ last character under consideration from the right
      count[c] = count[c] - 1;  /* take character token
      order[count[c]] = i; // populate order array with positions
    
    return order;
    
    \#+END<sub>SRC</sub> python

4.  Equivalence class

    1.  C<sub>i</sub> -partial cyclic shift of length L starting at position i
    2.  if C<sub>i</sub> ==  C<sub>j</sub> they beong to same equivalence class.
    3.  class[i] - Number of different cyclic shifts of length L strictly smaller than C<sub>i</sub>
    4.  C<sub>i</sub> `= C_j  iff class[i] =` class[j]

5.  Sort Doubled Cyclic Shifts

    Starting with a set of cyclic shifts of length L. Its possible to
    determinie the equivalence class partition of cyclic shifts of
    lenth 2\*|L|.
    
    1.  Let C<sub>i</sub> be cyclic shift of length L starting in i
    2.  Let C<sub>i'</sub> be doubled cyclic shift starting in i
    3.  C<sub>i'</sub> = C<sub>i</sub>,C<sub>i+L</sub> is a cyclic shift of length 2|L| composed
        of two shorter cyclic shifts
    4.  Comparing C<sub>i'</sub> and C<sub>j'</sub> 
        4.1 Compare C<sub>i</sub> and C<sub>j</sub> , i.e check class[i] `= class[j]
                4.2 Compoare C_{i+L} and C_{j+L} ie check class[i+l] =` class[j+l]
        4.3 If both hold then C<sub>i'</sub> and C<sub>j'</sub> belong to the same equivalence class.
    
    Example :
    
        S = ababaa$
        L = 2
        i = 2
        
        C_i = C_2 = ab
        C_{i+l} = C_{2+2} = C_4 = aa
        C_i' = C_2' = abaa = C_2,C_4

### General Stratergy<a id="sec-3-1-2" name="sec-3-1-2"></a>

### Initialization<a id="sec-3-1-3" name="sec-3-1-3"></a>

### Counting sort<a id="sec-3-1-4" name="sec-3-1-4"></a>

### Sort Doubled Cyclic Shifts<a id="sec-3-1-5" name="sec-3-1-5"></a>

### SortDouble Implementation<a id="sec-3-1-6" name="sec-3-1-6"></a>

### Updating Classes<a id="sec-3-1-7" name="sec-3-1-7"></a>

### Full Algorithm<a id="sec-3-1-8" name="sec-3-1-8"></a>